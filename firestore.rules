/**
 * This ruleset enforces a security model for a comprehensive marketplace application.
 * The core philosophy is to provide strict authorization based on user roles and
 * relationships (guest, host) while allowing flexibility in data schemas for rapid prototyping.
 *
 * Core Philosophy:
 * - Public data, like cultural experiences and reviews, is publicly readable to encourage discovery.
 * - Private user data, such as host profiles, is strictly confined to the owner.
 * - Transactional data, including bookings and messages, is accessible only to the direct participants involved.
 * - Administrative logs are completely inaccessible to client applications.
 *
 * Data Structure:
 * - User-specific data is organized under a user's private space (e.g., /users/{userId}/hosts/{hostId}).
 * - Public and transactional data are stored in top-level collections for straightforward querying.
 *
 * Key Security Decisions:
 * - Denormalization for Authorization: To ensure performant and secure access checks, documents contain
 *   the necessary user IDs (e.g., guestId, hostId) directly. This avoids slow and costly `get()` calls in rules.
 * - Disallowing Broad List Operations: For collections containing sensitive, multi-user data like bookings
 *   and messages, general `list` operations are disabled. This forces the client application to build
 *   specific, secure queries (e.g., fetching bookings for a specific guestId) that can be properly secured.
 * - Strict Ownership for Writes: All write operations (create, update, delete) are protected by
 *   verifying the user's identity against ownership fields on the documents.
 * - Structural Segregation: User-specific data (Host profiles) is kept in a user-scoped subcollection,
 *   which provides a clear and secure boundary from public-facing data like Experiences.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------
    // Helper Functions
    // --------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing data ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks for ownership on an existing document.
     * CRITICAL: Used for update/delete to prevent acting on non-existent data.
     */
    //function isExistingOwner(userId) {
    //  return isOwner(userId) && getAfter(userId) != null;
    //}

    // --------------------------------
    // Collection Rules
    // --------------------------------

    /**
     * @description Secures a user's private host profile. Only the owner can manage their profile.
     * @path /users/{userId}/hosts/{hostId}
     * @allow (create) An authenticated user creating their own host profile inside their user document tree.
     * @deny (get) A user trying to read another user's host profile.
     * @principle Restricts access to a user's own data tree using path-based ownership.
     */
    match /users/{userId}/hosts/{hostId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Manages cultural experiences. Experiences are public to view, but only the host who created it can manage it.
     * @path /experiences/{experienceId}
     * @allow (get) Any user, signed in or not, retrieving a specific experience.
     * @deny (update) A host trying to modify an experience created by another host.
     * @principle Implements a "Public Read with Owner-Only Writes" pattern, using a denormalized `hostId` (user's UID) for write authorization.
     */
    match /experiences/{experienceId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.hostId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.hostId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.hostId == request.auth.uid;
    }

    /**
     * @description Secures bookings. Only the guest who made the booking and the host of the experience can view or modify the booking.
     * @path /bookings/{bookingId}
     * @allow (create) A signed-in user creating a booking for themselves (guestId matches their UID).
     * @deny (get) A user trying to view a booking they are not a part of.
     * @deny (list) Any user trying to list all bookings in the system to prevent data leakage.
     * @principle Enforces shared access between a fixed set of collaborators (the guest and the host).
     */
    match /bookings/{bookingId} {
      allow get: if isSignedIn() && (resource.data.guestId == request.auth.uid || resource.data.hostId == request.auth.uid);
      allow list: if false; // Denied for security. Client must query with a where clause on guestId or hostId.
      allow create: if isSignedIn() && request.resource.data.guestId == request.auth.uid;
      allow update: if isSignedIn() && (resource.data.guestId == request.auth.uid || resource.data.hostId == request.auth.uid);
      allow delete: if isSignedIn() && (resource.data.guestId == request.auth.uid || resource.data.hostId == request.auth.uid);
    }

    /**
     * @description Manages reviews. Reviews are public to read, but only the guest who wrote it can create or delete it.
     * @path /reviews/{reviewId}
     * @allow (list) Any user, signed in or not, listing all reviews for an experience.
     * @deny (create) A user trying to create a review on behalf of another user.
     * @deny (update) A user trying to edit a review they did not write.
     * @principle Implements a "Public Read with Owner-Only Writes" pattern, where the `guestId` determines ownership.
     */
    match /reviews/{reviewId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.guestId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.guestId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.guestId == request.auth.uid;
    }

    /**
     * @description Secures private messages between a sender and a receiver.
     * @path /messages/{messageId}
     * @allow (get) The sender or the receiver reading a message they are a part of.
     * @deny (get) A third-party user trying to read a private message.
     * @deny (list) Any user trying to list all messages in the system.
     * @principle Enforces shared access between the message sender and receiver.
     */
    match /messages/{messageId} {
      allow get: if isSignedIn() && (resource.data.senderId == request.auth.uid || resource.data.receiverId == request.auth.uid);
      allow list: if false; // Denied for security. Client must use specific queries to get message threads.
      allow create: if isSignedIn() && request.resource.data.senderId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.senderId == request.auth.uid && resource.data.receiverId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.senderId == request.auth.uid;
    }

    /**
     * @description Locks down administrator logs. No client-side access is permitted.
     * @path /admin_logs/{adminLogId}
     * @allow (none) No operations are allowed from any client.
     * @deny (all) Any attempt to read or write to this collection will be rejected.
     * @principle Secures a collection for exclusive backend (Admin SDK) access by denying all client requests.
     */
    match /admin_logs/{adminLogId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}
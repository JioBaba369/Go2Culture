
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /* ────────────────────────────────── */
    /*           Helper Functions         */
    /* ────────────────────────────────── */

    // Is the requesting user signed in?
    function isSignedIn() {
      return request.auth != null;
    }

    // Does the requesting user's UID match the provided userId?
    function isSelf(uid) {
      return isSignedIn() && request.auth.uid == uid;
    }
    
    // Is the requesting user an admin?
    function isAdmin() {
      // In a production app, this should be a custom claim, not a hardcoded UID.
      // For example: `return request.auth.token.admin == true;`
      return isSignedIn() && request.auth.uid == '9vjYTvqyLHSOZj27shGfhgpwgDw1';
    }
    
    // Can the user create a review for this booking?
    function canCreateReview(bookingId) {
      let booking = get(/databases/$(database)/documents/bookings/$(bookingId)).data;
      // User must be the guest, and the booking must be confirmed and in the past.
      return booking != null &&
             isSelf(booking.guestId) &&
             booking.status == 'Confirmed' &&
             booking.bookingDate < request.time;
    }
    
    // Rate limit function for sending messages
    function canSendMessage() {
      // Path to the user's rate limit document for chat.
      let limitDocPath = /databases/$(database)/documents/users/$(request.auth.uid)/rateLimits/chat;
      // If the doc doesn't exist, they can send.
      // If it exists, check if the request time is at least 1s after the last message.
      return !exists(limitDocPath)
        || request.time > get(limitDocPath).data.lastMessageAt + duration.value(1, "s");
    }

    /* ────────────────────────────────── */
    /*           User Collections         */
    /* ────────────────────────────────── */

    match /users/{userId} {
      // Public can get user profiles.
      allow get: if true;
      // Listing all users is restricted to admins.
      allow list: if isAdmin();
      // A user can only create their own user document.
      allow create: if isSelf(userId);
      // Users can update their own profile, but cannot change their role or status. Admins can update anything.
      allow update: if (isSelf(userId)
        && !('role' in request.resource.data.diff(resource.data).affectedKeys())
        && !('status' in request.resource.data.diff(resource.data).affectedKeys())) || isAdmin();
      // Users cannot delete their accounts directly; this is handled via status field.
      allow delete: if false;

      // Host sub-collection contains public and private host-specific details.
      match /hosts/{hostId} {
        // Anyone can read a host's profile.
        allow read: if true;
        // Only the user themselves or an admin can create/update their host profile.
        allow write: if isSelf(userId) || isAdmin();
      }

      // Users can manage their own wishlist.
      match /wishlist/{experienceId} {
        allow read, write: if isSelf(userId);
      }
      
      // Users can only read their own referral data.
      match /referredUsers/{referredUserId} {
        allow get, list: if isSelf(userId) || isAdmin();
        // Writes are handled server-side to prevent fraud.
        allow write: if false;
      }

      // Users can manage their own notifications.
      match /notifications/{notificationId} {
        allow read, update, delete: if isSelf(userId);
        // Any signed-in user can create a notification for another user if the payload is correct.
        // This allows clients to trigger notifications for other users (e.g., host confirms booking for guest).
        allow create: if isSignedIn() && request.resource.data.userId == userId;
      }
      
      // Used for client-side rate-limiting.
      match /rateLimits/{document=**} {
        allow read, write: if isSelf(userId);
      }
    }

    /* ────────────────────────────────── */
    /*         Core App Collections       */
    /* ────────────────────────────────── */

    match /experiences/{experienceId} {
      // Anyone can read live experiences. Owners and Admins can read any status.
      allow read: if resource.data.status == 'live' || (isSignedIn() && isSelf(resource.data.userId)) || isAdmin();
      // Only a host (or admin) can create an experience for themselves.
      allow create: if isSignedIn() && (isSelf(request.resource.data.userId) || isAdmin());
      // Only the host who owns the experience (or an admin) can update it.
      allow update: if isSignedIn() && (isSelf(resource.data.userId) || isAdmin());
      // Soft delete by updating status to 'archived', don't allow hard delete.
      allow delete: if false;
    }

    match /bookings/{bookingId} {
      // A user can only create a booking for themselves.
      allow create: if isSignedIn() && isSelf(request.resource.data.guestId);
      
      // GET: Allow if user is a participant or admin.
      allow get: if isSignedIn() && (isSelf(resource.data.guestId) || isSelf(resource.data.hostId) || isAdmin());
      
      // LIST: Admins can list all. Users can list bookings where they are a participant.
      // This relies on a client-side `where('participantIds', 'array-contains', uid)` query.
      allow list: if isAdmin() || (isSignedIn() && request.auth.uid in resource.data.participantIds);
      
      // Complex update logic to handle various state transitions securely.
      allow update: if (isAdmin() || (isSignedIn()
          // 1. User must be a participant in the booking.
          && (isSelf(resource.data.guestId) || isSelf(resource.data.hostId))
          // 2. Certain core fields must be immutable.
          && !request.resource.data.diff(resource.data).affectedKeys().hasAny(['pricing', 'policySnapshot', 'payment', 'guestId', 'hostId', 'participantIds'])
          // 3. Define allowed state changes.
          && (
              // A. Guest can cancel their own booking.
              (isSelf(resource.data.guestId) && request.resource.data.status == "Cancelled") ||
              // B. Host can confirm a pending booking.
              (isSelf(resource.data.hostId) && request.resource.data.status == "Confirmed" && resource.data.status == "Pending") ||
              // C. Either participant can add or modify a reschedule request.
              ('rescheduleRequest' in request.resource.data.diff(resource.data).affectedKeys())
          )
      ));
      allow delete: if false;
    }

    match /reviews/{reviewId} {
      // Reviews are public.
      allow read: if true;
      // A guest can only create a review for a booking they attended.
      allow create: if canCreateReview(request.resource.data.bookingId);
      // A guest can update their own review. Admin can also moderate.
      allow update: if (isSignedIn() && isSelf(resource.data.guestId)) || isAdmin();
      allow delete: if isAdmin();
    }
    
    match /stories/{storyId} {
      // Public can read approved stories. Authors/admins can read any status.
      allow read: if resource.data.status == 'approved' || (isSignedIn() && isSelf(resource.data.authorId)) || isAdmin();
      // Users can submit stories in 'pending' state.
      allow create: if isSignedIn() && isSelf(request.resource.data.authorId) && request.resource.data.status == 'pending';
      // Only admins can approve/reject stories.
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /* ────────────────────────────────── */
    /*        Messaging Collections       */
    /* ────────────────────────────────── */

    match /conversations/{bookingId} {
      // LIST: A user can only list conversations they are a participant in.
      // This relies on a client-side `where('participants', 'array-contains', uid)` query.
      allow list: if (isSignedIn() && request.auth.uid in resource.data.participants) || isAdmin();
      
      // GET: A user can only get a conversation they are a participant in.
      allow get: if (isSignedIn() && request.auth.uid in resource.data.participants) || isAdmin();

      // CREATE: Conversation is created when booking is confirmed.
      // Rule ensures it's created for the correct booking and by a participant.
      allow create: if (isSignedIn() && (request.auth.uid in request.resource.data.participants))
                    && get(/databases/$(database)/documents/bookings/$(bookingId)).data.status == 'Confirmed'
                    && request.resource.data.id == bookingId;
      
      // UPDATE: Participants can update `lastMessage`, `readBy`, etc. but not core fields.
      allow update: if (isSignedIn() && (request.auth.uid in resource.data.participants) || isAdmin())
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastMessage', 'readBy', 'updatedAt', 'participantInfo']);
    }

    match /conversations/{bookingId}/messages/{messageId} {
        // READ/LIST: User must be a participant in the parent conversation.
        allow read, list: if (isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/conversations/$(bookingId)).data.participants) || isAdmin();
        
        // CREATE: User must be sender and a participant, with rate limiting.
        allow create: if canSendMessage() 
                    && isSelf(request.resource.data.senderId)
                    && (isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/conversations/$(bookingId)).data.participants);
                    
        // Messages are immutable.
        allow update, delete: if false;
    }

    /* ────────────────────────────────── */
    /*     Admin & System Collections     */
    /* ────────────────────────────────── */
    
    match /hostApplications/{applicationId} {
      // User can create their own application.
      allow create: if isSignedIn() && isSelf(request.resource.data.userId);
      // User can read their own application; admins can read any.
      allow read: if isAdmin() || (isSignedIn() && isSelf(resource.data.userId));
      // Only admins can approve, reject, or delete applications.
      allow update, delete: if isAdmin();
    }

    match /platformSettings/{settingId} {
        // Publicly readable settings (e.g., service fees).
        allow read: if true;
        allow write: if isAdmin();
    }

    match /jobs/{jobId} {
      allow read: if true;
      allow write: if isAdmin();
    }
    
    match /sponsors/{sponsorId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    match /coupons/{couponId} {
      // Any signed-in user can check if a coupon exists.
      allow get: if isSignedIn();
      // Only admins can manage the full list of coupons.
      allow list, create, update, delete: if isAdmin();
    }
    
    match /reports/{reportId} {
      allow create: if isSignedIn();
      allow read, update: if isAdmin();
      allow delete: if false;
    }

    match /auditLogs/{logId} {
        allow read: if isAdmin();
        // Allow admin-write from client to support logging without server-side functions.
        allow write: if isAdmin();
    }
  }
}
